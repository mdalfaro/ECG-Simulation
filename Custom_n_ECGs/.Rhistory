position = param_vector["curve_2_position"],
width = param_vector["curve_2_width"])
normal3 <- peak(time_vector,
amplitude = param_vector["curve_3_amplitude"],
position = param_vector["curve_3_position"],
width = param_vector["curve_3_width"])
normal4 <- peak(time_vector,
amplitude = param_vector["curve_4_amplitude"],
position = param_vector["curve_4_position"],
width = param_vector["curve_4_width"])
normal5 <- peak(time_vector,
amplitude = param_vector["curve_5_amplitude"],
position = param_vector["curve_5_position"],
width = param_vector["curve_5_width"])
return(normal1 + normal2 + normal3 + normal4 + normal5)
}
# Plot fitted data
x <- ecg_data$x
with(ecg_data, plot(x, y))
# Curve fitted by user
lines(x, newCurveFunc(uinput, x), col="blue")
# Plotting..........................................
# Plot real ecg curve (goal) & user-defined curve (guess) & optimizer
real_x <- ecg_data$x
real_y <- ecg_data$y
user_y <- newCurveFunc(param_vector = uinput, time_vector = ecg_data$x)
user_xy <- data.frame(x=x, y=user_y)
# Download Data
output$downloadData <- downloadHandler(
filename = function() {
print(paste(input$n, "_ecg_waves.csv", sep = ""))
paste(input$n, "_ecg_waves.csv", sep = "")
},
content = function(file) {
n_ecg_waves = rep_ecg(user_xy, as.integer(input$n))
write.csv(n_ecg_waves, file)
}
)
# Plot
matplot(cbind(real_x, x), cbind(real_y, user_y), col = cbind("black", "dodgerblue3"), xlab = "Time (Seconds)", ylab = "Surface potential (mVs)", pch = ".")
lines(real_x, real_y, col = 'black', lwd=2.5)
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
text(x=0.9, y=2.8, labels='User', cex=1.3, col='dodgerblue3')
text(x=0.885, y=2.4, labels='Baseline', cex=1.3, col='black')
text(x=0.98, y=2.8, labels='________', cex=1.3, col='dodgerblue3')
text(x=0.98, y=2.4, labels='________', cex=1.3, col='black')
})
}
shinyApp(ui = ui, server = server, options=list(width=1200, height=900))
# Libraries
library(shiny)
library(dplyr)
source('replicate_ecg')
ui <- fluidPage(
titlePanel(div(HTML("Simulate <em>n</em> Custom ECG Waves"))),
plotOutput("ecg_simulator"),
# Adjust n button
textInput("n", "Number of ECG Waves", "5"),
verbatimTextOutput("value"),
# Download Data Button
downloadButton("downloadData", "Download"),
fluidRow(
column(1),
column(2,
h4("Curve #1 (P)"),
numericInput(inputId = "curve_1_amplitude", label = "Amplitude", value = .2, step = 0.1),
numericInput(inputId = "curve_1_position", label = "Position", min = 0, max = 1.5, value = 0.25, step = 0.01),
numericInput(inputId = "curve_1_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #2 (Q)"),
numericInput(inputId = "curve_2_amplitude", label = "Amplitude", value = -.3, step = 0.1),
numericInput(inputId = "curve_2_position", label = "Position", min = 0, max = 1.5, value = .35, step = 0.01),
numericInput(inputId = "curve_2_width", label = "Width", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #3 (R)"),
numericInput(inputId = "curve_3_amplitude", label = "Amplitude", value = 3.1, step = 0.1),
numericInput(inputId = "curve_3_position", label = "Position", min = 0, max = 1.5, value = .375, step = 0.01),
numericInput(inputId = "curve_3_width", label = "Width", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #4 (S)"),
numericInput(inputId = "curve_4_amplitude", label = "Amplitude", value = -.1, step = 0.1),
numericInput(inputId = "curve_4_position", label = "Position", min = 0, max = 1.5, value = .45, step = 0.01),
numericInput(inputId = "curve_4_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #5 (T)"),
numericInput(inputId = "curve_5_amplitude", label = "Amplitude", value = .3, step = 0.1),
numericInput(inputId = "curve_5_position", label = "Position", min = 0, max = 1.5, value = .68, step = 0.01),
numericInput(inputId = "curve_5_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
)
)
)
server <- function(input, output, session) {
output$ecg_simulator <- renderPlot({
ecg_data <- read.csv("ecg_baseline.csv")
ecg_data$x <- (ecg_data$x - min(ecg_data$x))/diff(range(ecg_data$x)) # scale to range [0,1]
ecg_data$y <- ecg_data$y - median(ecg_data$y)  # bring baseline to 0
ecg_data$y <- ecg_data$y / max(ecg_data$y) * 3 # scale mV between 0 & 3
# We use the function peak() to define our own bell curve function
# Motivation: Define our own bell curve function instead of dnorm so that we don't have to fight the function always trying to integrate to 0.
peak <- function(x, amplitude = 1, position = 50, width = 1) {
amplitude * exp(-((x - position)^2)/(2*width^2))
}
# x value range
x <- seq(from = min(ecg_data$x), to = max(ecg_data$x), length = length(ecg_data$x))
# Input as list
uinput <- sapply(reactiveValuesToList(input), as.numeric)
# Function that creates user-defined curve
newCurveFunc <- function(param_vector, time_vector){
normal1 <- peak(time_vector,
amplitude = param_vector["curve_1_amplitude"],
position = param_vector["curve_1_position"],
width = param_vector["curve_1_width"])
normal2 <- peak(time_vector,
amplitude = param_vector["curve_2_amplitude"],
position = param_vector["curve_2_position"],
width = param_vector["curve_2_width"])
normal3 <- peak(time_vector,
amplitude = param_vector["curve_3_amplitude"],
position = param_vector["curve_3_position"],
width = param_vector["curve_3_width"])
normal4 <- peak(time_vector,
amplitude = param_vector["curve_4_amplitude"],
position = param_vector["curve_4_position"],
width = param_vector["curve_4_width"])
normal5 <- peak(time_vector,
amplitude = param_vector["curve_5_amplitude"],
position = param_vector["curve_5_position"],
width = param_vector["curve_5_width"])
return(normal1 + normal2 + normal3 + normal4 + normal5)
}
# Plot fitted data
x <- ecg_data$x
with(ecg_data, plot(x, y))
# Curve fitted by user
lines(x, newCurveFunc(uinput, x), col="blue")
# Plotting..........................................
# Plot real ecg curve (goal) & user-defined curve (guess) & optimizer
real_x <- ecg_data$x
real_y <- ecg_data$y
user_y <- newCurveFunc(param_vector = uinput, time_vector = ecg_data$x)
user_xy <- data.frame(x=x, y=user_y)
# Download Data
output$downloadData <- downloadHandler(
filename = function() {
print(paste(input$n, "_ecg_waves.csv", sep = ""))
paste(input$n, "_ecg_waves.csv", sep = "")
},
content = function(file) {
n_ecg_waves = rep_ecg(user_xy, as.integer(input$n))
write.csv(n_ecg_waves, file)
}
)
# Plot
matplot(cbind(real_x, x), cbind(real_y, user_y), col = cbind("black", "dodgerblue3"), xlab = "Time (Seconds)", ylab = "Surface potential (mVs)", pch = ".")
lines(real_x, real_y, col = 'black', lwd=2.5)
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
text(x=0.9, y=2.8, labels='User', cex=1.3, col='dodgerblue3')
text(x=0.885, y=2.4, labels='Baseline', cex=1.3, col='black')
text(x=0.98, y=2.8, labels='________', cex=1.3, col='dodgerblue3')
text(x=0.98, y=2.4, labels='________', cex=1.3, col='black')
})
}
shinyApp(ui = ui, server = server, options=list(width=1200, height=900))
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
# Libraries
library(shiny)
library(dplyr)
source('replicate_ecg')
ui <- fluidPage(
titlePanel(div(HTML("Simulate <em>n</em> Custom ECG Waves"))),
plotOutput("ecg_simulator"),
# Adjust n button
textInput("n", "Number of ECG Waves", "5"),
verbatimTextOutput("value"),
# Download Data Button
downloadButton("downloadData", "Download"),
fluidRow(
column(1),
column(2,
h4("Curve #1 (P)"),
numericInput(inputId = "curve_1_amplitude", label = "Amplitude", value = .2, step = 0.1),
numericInput(inputId = "curve_1_position", label = "Position", min = 0, max = 1.5, value = 0.25, step = 0.01),
numericInput(inputId = "curve_1_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #2 (Q)"),
numericInput(inputId = "curve_2_amplitude", label = "Amplitude", value = -.3, step = 0.1),
numericInput(inputId = "curve_2_position", label = "Position", min = 0, max = 1.5, value = .35, step = 0.01),
numericInput(inputId = "curve_2_width", label = "Width", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #3 (R)"),
numericInput(inputId = "curve_3_amplitude", label = "Amplitude", value = 3.23, step = 0.1),
numericInput(inputId = "curve_3_position", label = "Position", min = 0, max = 1.5, value = .375, step = 0.01),
numericInput(inputId = "curve_3_width", label = "Width", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #4 (S)"),
numericInput(inputId = "curve_4_amplitude", label = "Amplitude", value = -.1, step = 0.1),
numericInput(inputId = "curve_4_position", label = "Position", min = 0, max = 1.5, value = .45, step = 0.01),
numericInput(inputId = "curve_4_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #5 (T)"),
numericInput(inputId = "curve_5_amplitude", label = "Amplitude", value = .3, step = 0.1),
numericInput(inputId = "curve_5_position", label = "Position", min = 0, max = 1.5, value = .68, step = 0.01),
numericInput(inputId = "curve_5_width", label = "Width", min = 0.001, max = 2, value = 0.031, step = 0.01)
)
)
)
server <- function(input, output, session) {
output$ecg_simulator <- renderPlot({
ecg_data <- read.csv("ecg_baseline.csv")
ecg_data$x <- (ecg_data$x - min(ecg_data$x))/diff(range(ecg_data$x)) # scale to range [0,1]
ecg_data$y <- ecg_data$y - median(ecg_data$y)  # bring baseline to 0
ecg_data$y <- ecg_data$y / max(ecg_data$y) * 3 # scale mV between 0 & 3
# We use the function peak() to define our own bell curve function
# Motivation: Define our own bell curve function instead of dnorm so that we don't have to fight the function always trying to integrate to 0.
peak <- function(x, amplitude = 1, position = 50, width = 1) {
amplitude * exp(-((x - position)^2)/(2*width^2))
}
# x value range
x <- seq(from = min(ecg_data$x), to = max(ecg_data$x), length = length(ecg_data$x))
# Input as list
uinput <- sapply(reactiveValuesToList(input), as.numeric)
# Function that creates user-defined curve
newCurveFunc <- function(param_vector, time_vector){
normal1 <- peak(time_vector,
amplitude = param_vector["curve_1_amplitude"],
position = param_vector["curve_1_position"],
width = param_vector["curve_1_width"])
normal2 <- peak(time_vector,
amplitude = param_vector["curve_2_amplitude"],
position = param_vector["curve_2_position"],
width = param_vector["curve_2_width"])
normal3 <- peak(time_vector,
amplitude = param_vector["curve_3_amplitude"],
position = param_vector["curve_3_position"],
width = param_vector["curve_3_width"])
normal4 <- peak(time_vector,
amplitude = param_vector["curve_4_amplitude"],
position = param_vector["curve_4_position"],
width = param_vector["curve_4_width"])
normal5 <- peak(time_vector,
amplitude = param_vector["curve_5_amplitude"],
position = param_vector["curve_5_position"],
width = param_vector["curve_5_width"])
return(normal1 + normal2 + normal3 + normal4 + normal5)
}
# Plot fitted data
x <- ecg_data$x
with(ecg_data, plot(x, y))
# Curve fitted by user
lines(x, newCurveFunc(uinput, x), col="blue")
# Plotting..........................................
# Plot real ecg curve (goal) & user-defined curve (guess) & optimizer
real_x <- ecg_data$x
real_y <- ecg_data$y
user_y <- newCurveFunc(param_vector = uinput, time_vector = ecg_data$x)
user_xy <- data.frame(x=x, y=user_y)
# Download Data
output$downloadData <- downloadHandler(
filename = function() {
print(paste(input$n, "_ecg_waves.csv", sep = ""))
paste(input$n, "_ecg_waves.csv", sep = "")
},
content = function(file) {
n_ecg_waves = rep_ecg(user_xy, as.integer(input$n))
write.csv(n_ecg_waves, file)
}
)
# Plot
matplot(cbind(real_x, x), cbind(real_y, user_y), col = cbind("black", "dodgerblue3"), xlab = "Time (Seconds)", ylab = "Surface potential (mVs)", pch = ".")
lines(real_x, real_y, col = 'black', lwd=2.5)
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
# labels-----------
text(x=0.9, y=2.8, labels='User', cex=1.3, col='dodgerblue3')
text(x=0.885, y=2.4, labels='Baseline', cex=1.3, col='black')
text(x=0.98, y=2.8, labels='________', cex=1.3, col='dodgerblue3')
text(x=0.98, y=2.4, labels='________', cex=1.3, col='black')
})
}
shinyApp(ui = ui, server = server, options=list(width=1200, height=900))
peak <- function(x, amplitude = 1, position = 50, width = 1) {
amplitude * exp(-((x - position)^2)/(2*width^2))
}
peak(10)
peak(0.1)
peak(52)
dnorm(10)
dnorm(1)
nums <- seq(-2, 2, 0.01)
nums
lapply(nums, dnorm)
sapply(nums, dnorm)
probs <- sapply(nums, dnorm)
plot(probs)
dnorm ?
fasd
? dnorm
# Libraries
library(shiny)
library(dplyr)
source('replicate_ecg')
ui <- fluidPage(
titlePanel(div(HTML("Simulate <em>n</em> Custom ECG Waves"))),
plotOutput("ecg_simulator"),
# Adjust n button
textInput("n", "Number of ECG Waves", "5"),
verbatimTextOutput("value"),
# Download Data Button
downloadButton("downloadData", "Download"),
fluidRow(
column(1),
column(2,
h4("Curve #1 (P)"),
numericInput(inputId = "curve_1_mean", label = "Mean", min = 0, max = 1.5, value = 0.25, step = 0.01),
numericInput(inputId = "curve_1_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #2 (Q)"),
numericInput(inputId = "curve_2_mean", label = "Mean", min = 0, max = 1.5, value = .35, step = 0.01),
numericInput(inputId = "curve_2_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #3 (R)"),
numericInput(inputId = "curve_3_mean", label = "Mean", min = 0, max = 1.5, value = .375, step = 0.01),
numericInput(inputId = "curve_3_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #4 (S)"),
numericInput(inputId = "curve_4_mean", label = "Mean", min = 0, max = 1.5, value = .45, step = 0.01),
numericInput(inputId = "curve_4_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #5 (T)"),
numericInput(inputId = "curve_5_mean", label = "Mean", min = 0, max = 1.5, value = .68, step = 0.01),
numericInput(inputId = "curve_5_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
)
)
)
server <- function(input, output, session) {
output$ecg_simulator <- renderPlot({
ecg_data <- read.csv("ecg_baseline.csv")
ecg_data$x <- (ecg_data$x - min(ecg_data$x))/diff(range(ecg_data$x)) # scale to range [0,1]
ecg_data$y <- ecg_data$y - median(ecg_data$y)  # bring baseline to 0
ecg_data$y <- ecg_data$y / max(ecg_data$y) * 3 # scale mV between 0 & 3
# x value range
x <- seq(from = min(ecg_data$x), to = max(ecg_data$x), length = length(ecg_data$x))
# Input as list
uinput <- sapply(reactiveValuesToList(input), as.numeric)
# Function that creates user-defined curve
newCurveFunc <- function(param_vector, time_vector){
normal1 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal2 <- peak(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal3 <- peak(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal4 <- peak(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal5 <- peak(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
return(normal1 + normal2 + normal3 + normal4 + normal5)
}
# Plot fitted data
x <- ecg_data$x
with(ecg_data, plot(x, y))
# Curve fitted by user
lines(x, newCurveFunc(uinput, x), col="blue")
# Plotting..........................................
# Plot real ecg curve (goal) & user-defined curve (guess) & optimizer
real_x <- ecg_data$x
real_y <- ecg_data$y
user_y <- newCurveFunc(param_vector = uinput, time_vector = ecg_data$x)
user_xy <- data.frame(x=x, y=user_y)
# Download Data
output$downloadData <- downloadHandler(
filename = function() {
print(paste(input$n, "_ecg_waves.csv", sep = ""))
paste(input$n, "_ecg_waves.csv", sep = "")
},
content = function(file) {
n_ecg_waves = rep_ecg(user_xy, as.integer(input$n))
write.csv(n_ecg_waves, file)
}
)
# Plot
matplot(cbind(real_x, x), cbind(real_y, user_y), col = cbind("black", "dodgerblue3"), xlab = "Time (Seconds)", ylab = "Surface potential (mVs)", pch = ".")
lines(real_x, real_y, col = 'black', lwd=2.5)
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
# labels-----------
text(x=0.9, y=2.8, labels='User', cex=1.3, col='dodgerblue3')
text(x=0.885, y=2.4, labels='Baseline', cex=1.3, col='black')
text(x=0.98, y=2.8, labels='________', cex=1.3, col='dodgerblue3')
text(x=0.98, y=2.4, labels='________', cex=1.3, col='black')
})
}
shinyApp(ui = ui, server = server, options=list(width=1200, height=900))
# Libraries
library(shiny)
library(dplyr)
source('replicate_ecg')
ui <- fluidPage(
titlePanel(div(HTML("Simulate <em>n</em> Custom ECG Waves"))),
plotOutput("ecg_simulator"),
# Adjust n button
textInput("n", "Number of ECG Waves", "5"),
verbatimTextOutput("value"),
# Download Data Button
downloadButton("downloadData", "Download"),
fluidRow(
column(1),
column(2,
h4("Curve #1 (P)"),
numericInput(inputId = "curve_1_mean", label = "Mean", min = 0, max = 1.5, value = 0.25, step = 0.01),
numericInput(inputId = "curve_1_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #2 (Q)"),
numericInput(inputId = "curve_2_mean", label = "Mean", min = 0, max = 1.5, value = .35, step = 0.01),
numericInput(inputId = "curve_2_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #3 (R)"),
numericInput(inputId = "curve_3_mean", label = "Mean", min = 0, max = 1.5, value = .375, step = 0.01),
numericInput(inputId = "curve_3_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.01, step = 0.01)
),
column(2,
h4("Curve #4 (S)"),
numericInput(inputId = "curve_4_mean", label = "Mean", min = 0, max = 1.5, value = .45, step = 0.01),
numericInput(inputId = "curve_4_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
),
column(2,
h4("Curve #5 (T)"),
numericInput(inputId = "curve_5_mean", label = "Mean", min = 0, max = 1.5, value = .68, step = 0.01),
numericInput(inputId = "curve_5_sd", label = "Standard Deviation", min = 0.001, max = 2, value = 0.031, step = 0.01)
)
)
)
server <- function(input, output, session) {
output$ecg_simulator <- renderPlot({
ecg_data <- read.csv("ecg_baseline.csv")
ecg_data$x <- (ecg_data$x - min(ecg_data$x))/diff(range(ecg_data$x)) # scale to range [0,1]
ecg_data$y <- ecg_data$y - median(ecg_data$y)  # bring baseline to 0
ecg_data$y <- ecg_data$y / max(ecg_data$y) * 3 # scale mV between 0 & 3
# x value range
x <- seq(from = min(ecg_data$x), to = max(ecg_data$x), length = length(ecg_data$x))
# Input as list
uinput <- sapply(reactiveValuesToList(input), as.numeric)
# Function that creates user-defined curve
newCurveFunc <- function(param_vector, time_vector){
normal1 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal2 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal3 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal4 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
normal5 <- dnorm(time_vector,
mean = param_vector["curve_1_mean"],
sd = param_vector["curve_1_sd"])
return(normal1 + normal2 + normal3 + normal4 + normal5)
}
# Plot fitted data
x <- ecg_data$x
with(ecg_data, plot(x, y))
# Curve fitted by user
lines(x, newCurveFunc(uinput, x), col="blue")
# Plotting..........................................
# Plot real ecg curve (goal) & user-defined curve (guess) & optimizer
real_x <- ecg_data$x
real_y <- ecg_data$y
user_y <- newCurveFunc(param_vector = uinput, time_vector = ecg_data$x)
user_xy <- data.frame(x=x, y=user_y)
# Download Data
output$downloadData <- downloadHandler(
filename = function() {
print(paste(input$n, "_ecg_waves.csv", sep = ""))
paste(input$n, "_ecg_waves.csv", sep = "")
},
content = function(file) {
n_ecg_waves = rep_ecg(user_xy, as.integer(input$n))
write.csv(n_ecg_waves, file)
}
)
# Plot
matplot(cbind(real_x, x), cbind(real_y, user_y), col = cbind("black", "dodgerblue3"), xlab = "Time (Seconds)", ylab = "Surface potential (mVs)", pch = ".")
lines(real_x, real_y, col = 'black', lwd=2.5)
lines(x, user_y, col = 'dodgerblue3', lwd=2.5)
# labels-----------
text(x=0.9, y=2.8, labels='User', cex=1.3, col='dodgerblue3')
text(x=0.885, y=2.4, labels='Baseline', cex=1.3, col='black')
text(x=0.98, y=2.8, labels='________', cex=1.3, col='dodgerblue3')
text(x=0.98, y=2.4, labels='________', cex=1.3, col='black')
})
}
shinyApp(ui = ui, server = server, options=list(width=1200, height=900))
